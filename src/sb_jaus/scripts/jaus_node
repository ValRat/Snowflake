#! /usr/bin/env python3

# Created By: Gareth Ellis
# Created On: May 25, 2017
# Description: This node acts as the interface between Snowbot's in-house
#               JAUS library and ROS

import rospy
from concurrent.futures import ProcessPoolExecutor
import time
import asyncio
from math import atan2
import math
from format.jaus.judp import ConnectedJUDPProtocol, Packet, make_multicast_socket
from format.jaus import Id, Component
from format.jaus.services import *
from format.jaus.core.management import *

from nav_msgs.msg import Odometry
from geometry_msgs.msg import *

SUB_SYSTEM = 101
#192.168.1.101

# Platform Management will have node id of 1 and component id of 1
platform_management_component = \
    Component(id=Id(subsystem=SUB_SYSTEM, node=1, component=1),
              name="PlatformManagement",
              node_name="plat_man_comp",
              subsystem_name="jackfrostpm",
              services=[
                  TransportService,
                  DiscoveryService,
                  EventsService,
                  LivenessService,
                  AccessControlService
              ]
              )


#Navigation and Reporting Component is arbitrarily assigned node id of 1 and component id of 2
navigation_reporting_component = \
    Component(id=Id(subsystem=SUB_SYSTEM, node=1, component=2),
              name="NavigationReport",
              node_name="nav_rep_comp",
              subsystem_name="jackfrostnr",
              services=[
                TransportService,
                EventsService,
                AccessControlService,
                ManagementService,
                LivenessService,
                LocalWaypointDriverService,
                LocalWaypointListDriverService,
                VelocityStateSensorService,
                LocalPoseSensorService
              ],
              default_authority=5
              )

async def on_pose_change(dct):
    print("Pose change: " + str(dct['x']) + " " + str(dct['y']) + " " + str(dct['yaw']))
waypoint_pub = rospy.Publisher('/gps_manager/current_waypoint', PointStamped, queue_size=2)
async def on_waypoint_change(dct):
    point_stamped = PointStamped()
    point_stamped.point.x = float(dct['x'])
    point_stamped.point.y = float(dct['y'])
    waypoint_pub.publish(point_stamped)
    print("Waypoint: (" + dct['x'] + "," + dct['y'] + ")")
#navigation_reporting_component.local_pose_sensor.state.watcher(on_pose_change, keys=('x','y','yaw'))
navigation_reporting_component.local_waypoint_driver.state.watcher(on_waypoint_change, keys=('x','y'))



def robot_state_callback(pose_stamped):
    x = pose_stamped.pose.pose.position.x
    y = pose_stamped.pose.pose.position.y
    q = pose_stamped.pose.pose.orientation
    #yaw = atan2(2.0*(q.y*q.z + q.w*q.x), q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z)
    ysqr = y*y
    t3 = +2.0 * (q.w * q.z + q.x*q.y)
    t4 = +1.0 - 2.0 * (ysqr + q.z*q.z)
    yaw = math.atan2(t3, t4)
    msg = navigation_reporting_component.local_pose_sensor
    msg.x = x
    msg.y = y
    msg.yaw = yaw
    print("Recived ROS message")


def start_jaus(event_loop):
    _, protocol = event_loop.run_until_complete(event_loop.create_datagram_endpoint(
        lambda: ConnectedJUDPProtocol(loop=event_loop),
        sock=make_multicast_socket(3794)))

    # Hook up the Component with the protocol
    plat_man_connection = protocol.connect(Id(subsystem=SUB_SYSTEM, node=1, component=1))
    platform_management_component.listen(plat_man_connection)

    nav_rep_connection = protocol.connect(Id(subsystem=SUB_SYSTEM, node=1, component=2))
    navigation_reporting_component.listen(nav_rep_connection)


# Start ROS stuff
rospy.init_node('jaus_api')
rospy.Subscriber('/robot_pose_ekf/odom_combined', PoseWithCovarianceStamped, 
        robot_state_callback)

# Start Jaus
event_loop = asyncio.get_event_loop()
start_jaus(event_loop)

event_loop.run_forever()

